## 明确接下来要做的事

第一阶段的开发确实已经落幕了，尽管知道它的人还很少，在向周边的朋友同学分享后，似乎大家对背题这个主题不太感兴趣，这也跟大家目前所处的阶段有关，毕竟跟我同届的都工作两三年了，朋友同学的工作基本都稳定下来了，如果这个工具的出现是在我毕业前一年，说不定还有人用的机会。其实倒也不用担心有没有人用，时间会证明这个工具是否真的有价值。好了，是时候该明确下接下来要做的事了。

1. 让用户测试，指出bug，我找时间修复，不停循环此过程
2. 学习vue3，尝试用组合式API重写部分页面
3. 学习uniapp，准备开发辅助工具的移动版
4. 开发概况部分和赞助部分

## 总结开发时的一些东西

*2022/09/16*

1. 数据库设计有点问题，quiz表与tag表是多对多的关系，所以我没有在quiz表中设立一个tags字段，导致后期开发在查询时用orm不好查，还是用原始查询解决的。应当是要加一个tags字段，不过这样也有一点麻烦，因为我们要更新一个问题的标签时，不仅要维护quiz表本身的tags字段，还要维护tagquiz关联表。目前的表设计对于当前项目规模还是够用的，所以就算没有tags字段也能维护，但项目规模逐渐增大后，这个问题到时候就会有些头疼了，最好还是学下Sequelize的多对多模型是怎么做的，不然后期要爆炸。
2. 虽然前端用的vue3，但我还是在用vue2的方式书写，因为想快点把雏形肝出来，这样就可以早点让内测开始，验证这个项目的可行性。等背题功能完成上线测试环境后，我就先休息一段时间，然后边学习vue3边改造这个项目的代码。
3. 背题返回的题目逻辑是比较复杂的，在此做一个记录，防止以后回过头来看不懂了。

在用户配置完背题选项后，服务端筛选题目的逻辑：  
假设用户要背20道题，选题的核心逻辑是5:4:1。
- 定义预计条数：20 => 5:4:1 => 10(未知):8(理解):2(熟悉)
    对于不是整数的情况，先算出未知和理解的具体数量，最后用总量-(未知+理解)为熟悉的数量
- 定义条件: 题库，标签，重要程度
先根据条件找理解程度为熟悉的，如果熟悉未满足预计条数2条，则将（2条-select数量）累加到未知上，若满足，放入结果
再根据条件找理解程度为理解的，同理，未满足8条，则将(8-select数量)累加到未知上，若满足，放入结果
最后，根据条件找理解程度为未知的，select数量为之前的累加结果，放入结果，返回

现在是北京时间23:22分，经过测试，所有的核心功能可以说是搭建完毕了，非常开心，终于可以不用那么肝了，接下来我会主要做两件事，一件是找一些朋友一起做内测，还有就是准备面试，有空把这个项目的代码改改，现在可以说确实是shit mountain哈哈。

#### 开发公共题库功能

*2022/09/13*

昨天突然想到做一个公共题库功能，主要分为上传和下载两个功能。让有能力的人整理一套标准的题库出来，上传到公共题库，每个题库有一个共享密码，就像百度网盘的分享链接密码一样。个人用户可以通过共享密码将公共题库下载到自己的账户中，成为个人题库后，这套题库就可以随用户任意操作了。公共题库的好处是,方便用户，不需要从0开始收集题目，只需要拷贝一份现成题库，在其基础上修改上即可。  
实现这个功能很简单，需要增加两张表，分别是pub_repo和pub_quiz表（其实pub_repo的字段完全可以放在pub_quiz表中，但分两张表也无可厚非），分别代表公共题库和公共题目。用户选择自己账户内已有的一个题库，选择上传后，将题库id和用户id发给服务器，服务器调用一个上传的存储过程并传递参数，存储过程会找到这个题库以及该题库下所有的题目，将其拷贝到公共题库和公共题目表中，并给题库和题目都标上一个识别码。其他用户可以通过这个识别码下载题库，同样也是通过存储过程，就是把公共题库和公共题目表中的数据拷贝一份到其用户的题库和题目下。虽然这样会造成存储空间的浪费，但是在逻辑上是比较清晰的，这样的好处是方便我自己维护。

mysql存储过程踩坑：  
在使用游标提取数据时，由于之前声明了一个与游标对应sql中的select的一个列名相同的变量名，导致这列的数据怎么取都不对，后来改了声明的变量名后就解决了，这好像是mysql一直存在的bug，需要开发人员注意。

```sql
-- 与游标关联的sql select的列名tags重复，因此出现bug
declare tags json;
...
declare cur_quiz cursor for select question,answer,importance,tags from pub_quiz where `code` = code;
```

另外就是，个人用户在上传自己的题库后会收到一个该题库的共享密码，可是如果用户不想马上分享题库该怎么办呢，所以在题库列表中需要增加一列“共享密码”，不管这个题库是你上传到公共题库的还是你从公共题库下载过来的，只要你的题库是来自公共题库的一份拷贝，那么“共享密码”这一列就会有数据。（给repo表添加一个origin字段）

## 学习sequelize

*2022/09/08*

1. 不知道每次获取到的dbcontext是重新生成还是怎么样的（新请求过来时不会重新生成的）

## 策划重构

*2022/09/07*

因为后台没有做架构，扩展业务时发现与数据库交互比较困难。现在遇到的主要问题是，  
1. 对于事务类型的查询，目前只能原生手写，且无法复用
2. 查询出的数据是很原始的，我们需要对数据进行封装，再用于业务中
3. 在做数据操作时希望能获取插入或删除后受影响的那条记录


现在开始网上寻找解决方案    
第一种方案是，使用promise对mysql包提供的API进行封装。将对数据的操作方法(crud)封装成一个query函数，外部传入sql字符串和参数。
而事务也是同理，将事务封装成一个transaction函数，外部传入sql字符串数组和参数数组，字符串数组与参数数组是一一对应的关系。
这样设计的话，我会设计四层架构：  
- 第一层就是底部基础函数，包括query和transaction函数；
- 第二层就是根据业务分类对数据库操作(crud)的一些封装
- 第三层就是将数据库查询出来的结果进行处理，封装，成为业务层能用的数据；以及对数据操作的方法
- 第四层就是业务层，书写每个路由里的业务逻辑
这种方案对于第一个问题，确实可以复用了，但sql语句，参数都要自己写，但对于目前的需求来说还是可以接受的
对于第三个问题，封装的方法会返回一个promise，如果sql执行成功会返回结果，不过我不确定能否得到那条受影响的记录（需验证）  
研究了下事务函数的封装，发现，是用Promise.all来实现多个sql语句的执行的，只要其中一个sql语句执行失败就rollback；
但我们知道，all方法传入的多个promise之间是没有同步关系的，也就是说，它们是并行执行的，那么显然，方案一不满足我们的要求，因此我们选用方案二。

第二种方案是，使用orm框架，目前看起来用的较多的是sequelize。  
但是我个人认为，现在的业务需求量还远远达不到要上orm框架的地步，现在就用的话有点用牛刀杀鸡的味道。
orm框架能很好地解决原生手写和复用的问题，但也不太确定在做插入和删除时能否返回受影响的那条数据（应该是可以的，开发者肯定考虑到了）
如果是orm框架，可以省略掉架构的基础层。

#### 改造新计划

*2022/09/04*

最近背面试题一直在用这个小工具，发现还是有诸多小问题的，比如在PC端有界面分辨率的问题，在移动端不能适应浏览器自动变为夜间模式的问题等等。

我想让这个小工具可以给其他用户用，让他们无需关心服务端，只需要下载安装包即可。如果只是每个用户有自己的题库，用户与题库是一对一的关系，且用户与用户之间的题库是相互隔离的。那么改造一下当前程序其实也不难。所以我目前的改造计划是：

1. 增加用户模式，即每个用户可以创建自己的题库，并对其进行管理
2. PC端使用VUE3，抛弃Element-UI，学习使用另一种PC端的框架（iview）
3. 使用uniapp开发app端，仅实现背题部分和背题概况

背题概况搞三个图表
- 根据标签分类，可以看到自己每个标签的题目背过有多少道(大饼型)
- 根据熟悉程度分类，可以看到自己有多少背过的题目是熟悉的，有多少是理解的，有多少是不理解的（大饼型）
- 根据每日的背诵情况，生成线型图，可以看到自己过去一周内每天背了多少道

**数据库改造**

新增用户表，字段有id,昵称，密码

新增题库表，字段有用户id,题库id(uuid，主键)，题库名

题目表，新增字段题库id，是对应着题库表的外键

流程上，用户先使用昵称和密码登录，登录后，先选择题库，再选择出题或背题；若选择出题，提交的题目会新增一条记录在题目表，这个题目通过题库Id与题库表关联，题库表里存在用户与题库的关联，所以用户，题库，题目是都关联在一起的；若选择背题，只会更新题目表里的熟悉程度；当然，我们要新增题库管理相关的功能，比如新增题库，删除题库，编辑题库，用户登录后要先进入题库才能访问题目。

#### 做的有点乱

*2022/08/23*

添加了支持根据关键词搜索题目的功能。  
代码写的跟屎山一样，现在先凑合着用，打算等shoot-bug项目成型后，再来把该项目重写下，出题部分还是用vue写(可能用vue3)，背题部分用uniapp写(这样就可以在手机上背题啦)